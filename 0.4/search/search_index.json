{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"HTTPX Limiter","text":"<p>A lightweight package that provides rate-limited httpx transports.</p>"},{"location":"#installation","title":"Installation","text":"<p>The package is published on PyPI. Install it, for example, with</p> <pre><code>pip install httpx-limiter\n</code></pre>"},{"location":"#copyright","title":"Copyright","text":"<ul> <li>Copyright \u00a9 2024, 2025 Moritz E. Beber.</li> <li>Free software distributed under the Apache Software License   2.0.</li> </ul>"},{"location":"api/","title":"Reference API","text":"<p>The following classes are exposed to the user:</p> <ul> <li><code>Rate</code></li> <li><code>AsyncLimiter</code></li> <li><code>AsyncRateLimitedTransport</code></li> <li><code>AbstractRateLimiterRepository</code></li> <li><code>AsyncMultiRateLimitedTransport</code></li> </ul>"},{"location":"api/#httpx_limiter","title":"<code>httpx_limiter</code>","text":"<p>Provide top level symbols.</p>"},{"location":"api/#httpx_limiter.Rate","title":"<code>Rate</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Define the rate.</p>"},{"location":"api/#httpx_limiter.Rate.duration","title":"<code>duration: timedelta</code>  <code>instance-attribute</code>","text":""},{"location":"api/#httpx_limiter.Rate.magnitude","title":"<code>magnitude: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/#httpx_limiter.Rate.create","title":"<code>create(magnitude: int = 1, duration: timedelta | Number = 1) -&gt; Rate</code>  <code>classmethod</code>","text":"<p>Create a rate.</p>"},{"location":"api/#httpx_limiter.Rate.in_milliseconds","title":"<code>in_milliseconds() -&gt; int</code>","text":"<p>Return the duration in unit milliseconds.</p>"},{"location":"api/#httpx_limiter.AsyncLimiter","title":"<code>AsyncLimiter</code>","text":"<p>Define an asynchronous limiter that composes the pyrate limiter.</p> <p>This class encapsulates the creation and configuration of a pyrate-limiter Limiter with appropriate async bucket wrapper and settings.</p> <p>Parameters:</p> Name Type Description Default <code>limiter</code> <code>Limiter</code> <p>An instance of an asynchronous pyrate limiter.</p> required <code>**kwargs</code> <code>dict[str, object]</code> <p>Additional keyword arguments for the parent classes.</p> <code>{}</code>"},{"location":"api/#httpx_limiter.AsyncLimiter.__aenter__","title":"<code>__aenter__() -&gt; AsyncLimiter</code>  <code>async</code>","text":"<p>Acquire a token upon entering the asynchronous context.</p>"},{"location":"api/#httpx_limiter.AsyncLimiter.__aexit__","title":"<code>__aexit__(_exc_type: type[BaseException] | None, _exc_val: BaseException | None, _exc_tb: TracebackType | None) -&gt; None</code>  <code>async</code>","text":"<p>Exit the asynchronous context.</p>"},{"location":"api/#httpx_limiter.AsyncLimiter.__init__","title":"<code>__init__(*, limiter: Limiter, **kwargs: dict[str, object]) -&gt; None</code>","text":""},{"location":"api/#httpx_limiter.AsyncLimiter.create","title":"<code>create(*rates: Rate, **kwargs: Unpack[PyRateLimiterKeywordArguments]) -&gt; AsyncLimiter</code>  <code>classmethod</code>","text":"<p>Create an instance of AsyncLimiter.</p>"},{"location":"api/#httpx_limiter.AsyncRateLimitedTransport","title":"<code>AsyncRateLimitedTransport</code>","text":"<p>               Bases: <code>AsyncBaseTransport</code></p> <p>Define the asynchronous rate-limited transport.</p> <p>This transport consists of a composed transport for handling requests and an implementation of a leaky bucket algorithm in order to rate-limit the number of requests.</p>"},{"location":"api/#httpx_limiter.AsyncRateLimitedTransport.__init__","title":"<code>__init__(*, limiter: AsyncLimiter, transport: httpx.AsyncBaseTransport, **kwargs: dict[str, object]) -&gt; None</code>","text":""},{"location":"api/#httpx_limiter.AsyncRateLimitedTransport.create","title":"<code>create(*rates: Rate, **kwargs: Unpack[HTTPXAsyncHTTPTransportKeywordArguments]) -&gt; AsyncRateLimitedTransport</code>  <code>classmethod</code>","text":"<p>Create an instance of asynchronous rate-limited transport.</p> <p>This factory method constructs the instance with an underlying <code>httpx.AsyncHTTPTransport</code>. That transport is passed any additional keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>*rates</code> <code>Rate</code> <p>One or more rate limits to apply.</p> <code>()</code> <code>**kwargs</code> <code>Unpack[HTTPXAsyncHTTPTransportKeywordArguments]</code> <p>Additional keyword arguments are used in the construction of an <code>httpx.AsyncHTTPTransport</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncRateLimitedTransport</code> <p>A default instance of the class created from the given arguments.</p>"},{"location":"api/#httpx_limiter.AsyncRateLimitedTransport.handle_async_request","title":"<code>handle_async_request(request: httpx.Request) -&gt; httpx.Response</code>  <code>async</code>","text":"<p>Handle an asynchronous request with rate limiting.</p>"},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository","title":"<code>AbstractRateLimiterRepository</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Define the abstract repository for rate limiters.</p> <p>This abstract base class provides a framework for managing rate limiters based on HTTP requests. It maintains a cache of rate limiters and provides methods to retrieve request-specific identifiers, rates, and limiters.</p> <p>Subclasses must implement methods to determine how requests are identified and what rate limits should be applied to them.</p> <p>Methods:</p> Name Description <code>get_identifier</code> <p>Return a request-specific identifier.</p> <code>get_rates</code> <p>Return one or more request-specific rates.</p> <code>get</code> <p>Return a request-specific rate limiter.</p>"},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository.__init__","title":"<code>__init__(**kwargs: dict[str, object]) -&gt; None</code>","text":""},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository.get","title":"<code>get(request: httpx.Request) -&gt; AsyncLimiter</code>","text":"<p>Return a request-specific rate limiter.</p>"},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository.get_identifier","title":"<code>get_identifier(request: httpx.Request) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return a request-specific identifier.</p>"},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository.get_rates","title":"<code>get_rates(request: httpx.Request) -&gt; Sequence[Rate]</code>  <code>abstractmethod</code>","text":"<p>Return one or more request-specific rates.</p>"},{"location":"api/#httpx_limiter.AsyncMultiRateLimitedTransport","title":"<code>AsyncMultiRateLimitedTransport</code>","text":"<p>               Bases: <code>AsyncBaseTransport</code></p> <p>Define the asynchronous multiple rate-limited transport.</p> <p>This transport consists of a composed transport for handling requests and a repository for rate limiters that are selected based on the request.</p>"},{"location":"api/#httpx_limiter.AsyncMultiRateLimitedTransport.__init__","title":"<code>__init__(*, repository: AbstractRateLimiterRepository, transport: httpx.AsyncBaseTransport, **kwargs: dict[str, object]) -&gt; None</code>","text":""},{"location":"api/#httpx_limiter.AsyncMultiRateLimitedTransport.create","title":"<code>create(*, repository: AbstractRateLimiterRepository, **kwargs: Unpack[HTTPXAsyncHTTPTransportKeywordArguments]) -&gt; AsyncMultiRateLimitedTransport</code>  <code>classmethod</code>","text":"<p>Create an instance of an asynchronous multiple rate-limited transport.</p> <p>This factory method constructs the instance with an underlying <code>httpx.AsyncHTTPTransport</code>. That transport is passed any additional keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>repository</code> <code>AbstractRateLimiterRepository</code> <p>The repository to use for rate limiters.</p> required <code>**kwargs</code> <code>Unpack[HTTPXAsyncHTTPTransportKeywordArguments]</code> <p>Additional keyword arguments are used in the construction of an <code>httpx.AsyncHTTPTransport</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncMultiRateLimitedTransport</code> <p>A default instance of the class created from the given arguments.</p>"},{"location":"api/#httpx_limiter.AsyncMultiRateLimitedTransport.handle_async_request","title":"<code>handle_async_request(request: httpx.Request) -&gt; httpx.Response</code>  <code>async</code>","text":"<p>Handle an asynchronous request with rate limiting.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>You can limit the number of requests made by an HTTPX client using the transports provided in this package. That is useful in situations when you need to make a large number of asynchronous requests against endpoints that implement a rate limit.</p>"},{"location":"tutorial/#single-rate-limit","title":"Single Rate Limit","text":"<p>The simplest use case is to apply a single rate limit to all requests. If you want to be able to make twenty requests per second, for example, use the following code:</p> <pre><code>import httpx\nfrom httpx_limiter import AsyncRateLimitedTransport, Rate\n\nasync def main():\n    async with httpx.AsyncClient(\n        transport=AsyncRateLimitedTransport.create(Rate.create(magnitude=20)),\n    ) as client:\n        response = await client.get(\"https://httpbin.org\")\n</code></pre> <p>Warning</p> <p>Due to limitations in the design of the underlying leaky bucket implementation, which is used to implement the rate limiting, the magnitude of the rate is also the maximum capacity of the bucket. That means, if you set a rate that is larger than one, a burst of requests equal to that capacity will be allowed. If you do not want to allow any bursts, set the magnitude to one, but the duration to the inverse of your desired rate. If you want to allow twenty requests per second, for example, set the magnitude to 1 and the duration to 0.05 seconds.</p> <pre><code>Rate.create(magnitude=1, duration=1/20)\n</code></pre>"},{"location":"tutorial/#multiple-rate-limits","title":"Multiple Rate Limits","text":"<p>For more advanced use cases, you can apply different rate limits based on a concrete implementation of the <code>AbstractRateLimiterRepository</code>. There are two relevant methods that both get passed the current request. One method needs to identify which rate limit to apply, and the other method sets the rate limit itself. See the following example:</p> <pre><code>import httpx\nfrom httpx_limiter import (\n    AbstractRateLimiterRepository,\n    AsyncMultiRateLimitedTransport,\n    Rate\n)\n\n\nclass DomainBasedRateLimiterRepository(AbstractRateLimiterRepository):\n    \"\"\"Apply different rate limits based on the domain being requested.\"\"\"\n\n    def get_identifier(self, request: httpx.Request) -&gt; str:\n        \"\"\"Return the domain as the identifier for rate limiting.\"\"\"\n        return request.url.host\n\n    def get_rate(self, request: httpx.Request) -&gt; Rate:\n        \"\"\"Apply the same, but independent rate limit to each domain.\"\"\"\n        return Rate.create(magnitude=25)\n\n\nclient = httpx.AsyncClient(\n    transport=AsyncMultiRateLimitedTransport.create(\n        repository=DomainBasedRateLimiterRepository(),\n    ),\n)\n</code></pre> <p>Tip</p> <p>You are free to ignore the request parameter and use global information like the time of day to determine the rate limit.</p> <pre><code>from datetime import datetime, timezone\n\nimport httpx\nfrom httpx_limiter import AbstractRateLimiterRepository, Rate\n\n\nclass DayNightRateLimiterRepository(AbstractRateLimiterRepository):\n    \"\"\"Apply different rate limits based on the time of day.\"\"\"\n\n    def get_identifier(self, _: httpx.Request) -&gt; str:\n        \"\"\"Identify whether it is currently day or night.\"\"\"\n        if 6 &lt;= datetime.now(tz=timezone.utc).hour &lt; 18:\n            return \"day\"\n\n        return \"night\"\n\n    def get_rates(self, _: httpx.Request) -&gt; Sequence[Rate]:\n        \"\"\"Apply different rate limits during the day or night.\"\"\"\n        if self.get_identifier(_) == \"day\":\n            return [Rate.create(magnitude=10)]\n\n        return [Rate.create(magnitude=100)]\n</code></pre>"}]}