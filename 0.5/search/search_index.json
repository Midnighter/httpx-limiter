{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"HTTPX Limiter","text":"<p>A lightweight package that provides rate-limited httpx transports.</p>"},{"location":"#installation","title":"Installation","text":"<p>The package is published on PyPI. Install it, for example, with the aiolimiter backend.</p> <pre><code>pip install 'httpx-limiter[aiolimiter]'\n</code></pre> <p>There is also a pyrate-limiter backend available.</p> <pre><code>pip install 'httpx-limiter[pyrate]'\n</code></pre>"},{"location":"#rate-limiter-backends","title":"Rate Limiter Backends","text":"<p>This package provides two different asynchronous rate limiter implementations to choose from:</p> <ol> <li>aiolimiter</li> <li>pyrate-limiter</li> </ol> <p>Warning</p> <p>While both implementations fulfill similar purposes, there are significant differences between them. Please read the descriptions below to make an informed decision about which one best suits your needs.</p>"},{"location":"#1-aiolimiter","title":"1. aiolimiter","text":"<ul> <li>Single rate limit only: Supports only one rate limit at a time</li> <li>Lightweight: Minimal dependencies and simpler configuration</li> <li>Linear token refresh rate: As an example, if you set a rate of 2 per second,     roughly one token will be added every 500 milliseconds</li> </ul> <pre><code>from httpx_limiter.aiolimiter import AiolimiterAsyncLimiter\n\nlimiter = AiolimiterAsyncLimiter.create(Rate.create(magnitude=20))\n</code></pre>"},{"location":"#2-pyrate-limiter","title":"2. pyrate-limiter","text":"<ul> <li>Multiple rate limits: Support for multiple concurrent rate limits, for example,     10 requests per second and 100 requests per minute</li> <li>Flexible configuration: Comprehensive configuration options</li> <li>Multiprocessing dependency: Current implementation depends on <code>multiprocessing</code>     which may not be available in all environments, such as pyodide</li> <li>Stepwise token refresh rate: As an example, if you set a rate of 2 per second,     two token will be added every second</li> </ul> <pre><code>from httpx_limiter.pyrate import PyrateAsyncLimiter\n\n# Single rate limit\nlimiter = PyrateAsyncLimiter.create(Rate.create(magnitude=20))\n\n# Multiple rate limits\nlimiter = PyrateAsyncLimiter.create(\n    Rate.create(magnitude=10),  # 10 per second\n    Rate.create(magnitude=100, duration=60),  # 100 per minute\n)\n</code></pre>"},{"location":"#copyright","title":"Copyright","text":"<ul> <li>Copyright \u00a9 2024, 2025 Moritz E. Beber.</li> <li>Free software distributed under the Apache Software License     2.0.</li> </ul>"},{"location":"api/","title":"Reference API","text":"<p>The following classes are exposed to the user:</p> <ul> <li><code>Rate</code></li> <li><code>AbstractAsyncLimiter</code></li> <li><code>AsyncRateLimitedTransport</code></li> <li><code>AbstractRateLimiterRepository</code></li> <li><code>AsyncMultiRateLimitedTransport</code></li> <li><code>AiolimiterAsyncLimiter</code></li> <li><code>PyrateAsyncLimiter</code></li> </ul>"},{"location":"api/#httpx_limiter","title":"<code>httpx_limiter</code>","text":"<p>Provide top level symbols.</p>"},{"location":"api/#httpx_limiter.Rate","title":"<code>Rate</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Define the rate.</p>"},{"location":"api/#httpx_limiter.Rate.duration","title":"<code>duration: timedelta</code>  <code>instance-attribute</code>","text":""},{"location":"api/#httpx_limiter.Rate.magnitude","title":"<code>magnitude: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/#httpx_limiter.Rate.create","title":"<code>create(magnitude: int = 1, duration: timedelta | Number = 1) -&gt; Rate</code>  <code>classmethod</code>","text":"<p>Create a rate.</p>"},{"location":"api/#httpx_limiter.Rate.in_milliseconds","title":"<code>in_milliseconds() -&gt; int</code>","text":"<p>Return the duration in unit milliseconds.</p>"},{"location":"api/#httpx_limiter.Rate.in_seconds","title":"<code>in_seconds() -&gt; float</code>","text":"<p>Return the duration in unit seconds.</p>"},{"location":"api/#httpx_limiter.AbstractAsyncLimiter","title":"<code>AbstractAsyncLimiter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Define an abstract base class for asynchronous rate limiters.</p> <p>This interface dictates that all asynchronous rate limiters shall implement the context manager protocol.</p>"},{"location":"api/#httpx_limiter.AbstractAsyncLimiter.__aenter__","title":"<code>__aenter__() -&gt; AbstractAsyncLimiter</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Acquire a rate limit token upon entering the asynchronous context.</p>"},{"location":"api/#httpx_limiter.AbstractAsyncLimiter.__aexit__","title":"<code>__aexit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -&gt; None</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Exit the asynchronous context.</p>"},{"location":"api/#httpx_limiter.AsyncRateLimitedTransport","title":"<code>AsyncRateLimitedTransport</code>","text":"<p>               Bases: <code>AsyncBaseTransport</code></p> <p>Define the asynchronous rate-limited transport.</p> <p>This transport consists of a composed transport for handling requests and an implementation of a leaky bucket algorithm in order to rate-limit the number of requests.</p>"},{"location":"api/#httpx_limiter.AsyncRateLimitedTransport.__init__","title":"<code>__init__(*, limiter: AbstractAsyncLimiter, transport: httpx.AsyncBaseTransport, **kwargs: dict[str, object]) -&gt; None</code>","text":""},{"location":"api/#httpx_limiter.AsyncRateLimitedTransport.create","title":"<code>create(limiter: AbstractAsyncLimiter, **kwargs: Unpack[HTTPXAsyncHTTPTransportKeywordArguments]) -&gt; AsyncRateLimitedTransport</code>  <code>classmethod</code>","text":"<p>Create an instance of asynchronous rate-limited transport.</p> <p>This factory method constructs the instance with an underlying <code>httpx.AsyncHTTPTransport</code>. That transport is passed any additional keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>limiter</code> <code>AbstractAsyncLimiter</code> <p>A concrete instance of an asynchronous limiter.</p> required <code>**kwargs</code> <code>Unpack[HTTPXAsyncHTTPTransportKeywordArguments]</code> <p>Additional keyword arguments are used in the construction of an <code>httpx.AsyncHTTPTransport</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncRateLimitedTransport</code> <p>A default instance of the class created from the given arguments.</p>"},{"location":"api/#httpx_limiter.AsyncRateLimitedTransport.handle_async_request","title":"<code>handle_async_request(request: httpx.Request) -&gt; httpx.Response</code>  <code>async</code>","text":"<p>Handle an asynchronous request with rate limiting.</p>"},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository","title":"<code>AbstractRateLimiterRepository</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Define the abstract repository for rate limiters.</p> <p>This abstract base class provides a framework for managing rate limiters based on HTTP requests. It maintains a cache of rate limiters and provides methods to retrieve request-specific identifiers, rates, and limiters.</p> <p>Subclasses must implement methods to determine how requests are identified and what rate limits should be applied to them.</p> <p>Methods:</p> Name Description <code>get_identifier</code> <p>Return a request-specific identifier.</p> <code>get_rates</code> <p>Return one or more request-specific rates.</p> <code>get</code> <p>Return a request-specific rate limiter.</p>"},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository.__init__","title":"<code>__init__(**kwargs: dict[str, object]) -&gt; None</code>","text":""},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository.create","title":"<code>create(request: httpx.Request) -&gt; AbstractAsyncLimiter</code>  <code>abstractmethod</code>","text":"<p>Return a request-specific rate limiter.</p>"},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository.get","title":"<code>get(request: httpx.Request) -&gt; AbstractAsyncLimiter</code>","text":"<p>Return a request-specific rate limiter.</p>"},{"location":"api/#httpx_limiter.AbstractRateLimiterRepository.get_identifier","title":"<code>get_identifier(request: httpx.Request) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return a request-specific identifier.</p>"},{"location":"api/#httpx_limiter.AsyncMultiRateLimitedTransport","title":"<code>AsyncMultiRateLimitedTransport</code>","text":"<p>               Bases: <code>AsyncBaseTransport</code></p> <p>Define the asynchronous multiple rate-limited transport.</p> <p>This transport consists of a composed transport for handling requests and a repository for rate limiters that are selected based on the request.</p>"},{"location":"api/#httpx_limiter.AsyncMultiRateLimitedTransport.__init__","title":"<code>__init__(*, repository: AbstractRateLimiterRepository, transport: httpx.AsyncBaseTransport, **kwargs: dict[str, object]) -&gt; None</code>","text":""},{"location":"api/#httpx_limiter.AsyncMultiRateLimitedTransport.create","title":"<code>create(*, repository: AbstractRateLimiterRepository, **kwargs: Unpack[HTTPXAsyncHTTPTransportKeywordArguments]) -&gt; AsyncMultiRateLimitedTransport</code>  <code>classmethod</code>","text":"<p>Create an instance of an asynchronous multiple rate-limited transport.</p> <p>This factory method constructs the instance with an underlying <code>httpx.AsyncHTTPTransport</code>. That transport is passed any additional keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>repository</code> <code>AbstractRateLimiterRepository</code> <p>The repository to use for rate limiters.</p> required <code>**kwargs</code> <code>Unpack[HTTPXAsyncHTTPTransportKeywordArguments]</code> <p>Additional keyword arguments are used in the construction of an <code>httpx.AsyncHTTPTransport</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncMultiRateLimitedTransport</code> <p>A default instance of the class created from the given arguments.</p>"},{"location":"api/#httpx_limiter.AsyncMultiRateLimitedTransport.handle_async_request","title":"<code>handle_async_request(request: httpx.Request) -&gt; httpx.Response</code>  <code>async</code>","text":"<p>Handle an asynchronous request with rate limiting.</p>"},{"location":"api/#httpx_limiter.aiolimiter","title":"<code>httpx_limiter.aiolimiter</code>","text":"<p>Provide aiolimiter-based rate limiting functionality.</p>"},{"location":"api/#httpx_limiter.aiolimiter.AiolimiterAsyncLimiter","title":"<code>AiolimiterAsyncLimiter</code>","text":"<p>               Bases: <code>AbstractAsyncLimiter</code></p> <p>Define an asynchronous limiter that composes the aiolimiter AsyncLimiter.</p> <p>This class encapsulates the creation and configuration of an aiolimiter AsyncLimiter with appropriate settings.</p> <p>Parameters:</p> Name Type Description Default <code>limiter</code> <code>AsyncLimiter</code> <p>An instance of an aiolimiter AsyncLimiter.</p> required <code>**kwargs</code> <code>dict[str, object]</code> <p>Additional keyword arguments for the parent classes.</p> <code>{}</code>"},{"location":"api/#httpx_limiter.aiolimiter.AiolimiterAsyncLimiter.__aenter__","title":"<code>__aenter__() -&gt; AiolimiterAsyncLimiter</code>  <code>async</code>","text":"<p>Acquire a token upon entering the asynchronous context.</p>"},{"location":"api/#httpx_limiter.aiolimiter.AiolimiterAsyncLimiter.__aexit__","title":"<code>__aexit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -&gt; None</code>  <code>async</code>","text":"<p>Exit the asynchronous context.</p>"},{"location":"api/#httpx_limiter.aiolimiter.AiolimiterAsyncLimiter.__init__","title":"<code>__init__(*, limiter: AsyncLimiter, **kwargs: dict[str, object]) -&gt; None</code>","text":""},{"location":"api/#httpx_limiter.aiolimiter.AiolimiterAsyncLimiter.create","title":"<code>create(rate: Rate) -&gt; AiolimiterAsyncLimiter</code>  <code>classmethod</code>","text":"<p>Create an instance of AiolimiterAsyncLimiter.</p> <p>Note: aiolimiter only supports a single rate limit, unlike pyrate-limiter which supports multiple rates.</p>"},{"location":"api/#httpx_limiter.pyrate","title":"<code>httpx_limiter.pyrate</code>","text":"<p>Provide pyrate-based rate limiting functionality.</p>"},{"location":"api/#httpx_limiter.pyrate.PyrateAsyncLimiter","title":"<code>PyrateAsyncLimiter</code>","text":"<p>               Bases: <code>AbstractAsyncLimiter</code></p> <p>Define an asynchronous limiter that composes the pyrate limiter.</p> <p>This class encapsulates the creation and configuration of a pyrate-limiter Limiter with appropriate async bucket wrapper and settings.</p> <p>Parameters:</p> Name Type Description Default <code>limiter</code> <code>Limiter</code> <p>An instance of an asynchronous pyrate limiter.</p> required <code>**kwargs</code> <code>dict[str, object]</code> <p>Additional keyword arguments for the parent classes.</p> <code>{}</code>"},{"location":"api/#httpx_limiter.pyrate.PyrateAsyncLimiter.__aenter__","title":"<code>__aenter__() -&gt; PyrateAsyncLimiter</code>  <code>async</code>","text":"<p>Acquire a token upon entering the asynchronous context.</p>"},{"location":"api/#httpx_limiter.pyrate.PyrateAsyncLimiter.__aexit__","title":"<code>__aexit__(_exc_type: type[BaseException] | None, _exc_val: BaseException | None, _exc_tb: TracebackType | None) -&gt; None</code>  <code>async</code>","text":"<p>Exit the asynchronous context.</p>"},{"location":"api/#httpx_limiter.pyrate.PyrateAsyncLimiter.__init__","title":"<code>__init__(*, limiter: Limiter, **kwargs: dict[str, object]) -&gt; None</code>","text":""},{"location":"api/#httpx_limiter.pyrate.PyrateAsyncLimiter.create","title":"<code>create(*rates: Rate, **kwargs: Unpack[PyRateLimiterKeywordArguments]) -&gt; PyrateAsyncLimiter</code>  <code>classmethod</code>","text":"<p>Create an instance of PyrateAsyncLimiter.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>You can limit the number of requests made by an HTTPX client using the transports provided in this package. That is useful in situations when you need to make a large number of asynchronous requests against endpoints that implement a rate limit.</p>"},{"location":"tutorial/#single-rate-limit","title":"Single Rate Limit","text":"<p>The simplest use case is to apply a single rate limit to all requests. If you want to be able to make twenty requests per second, for example, use the following code:</p> <pre><code>import httpx\nfrom httpx_limiter import AsyncRateLimitedTransport, Rate\nfrom httpx_limiter.pyrate import PyrateAsyncLimiter\n\nasync def main():\n    limiter = PyrateAsyncLimiter.create(Rate.create(magnitude=20))\n    async with httpx.AsyncClient(\n        transport=AsyncRateLimitedTransport.create(limiter=limiter),\n    ) as client:\n        response = await client.get(\"https://httpbin.org\")\n</code></pre> <p>Warning</p> <p>Due to limitations in the design of the underlying leaky bucket implementation, which is used to implement the rate limiting, the magnitude of the rate is also the maximum capacity of the bucket. That means, if you set a rate that is larger than one, a burst of requests equal to that capacity will be allowed. If you do not want to allow any bursts, set the magnitude to one, but the duration to the inverse of your desired rate. If you want to allow twenty requests per second, for example, set the magnitude to 1 and the duration to 0.05 seconds.</p> <pre><code>Rate.create(magnitude=1, duration=1/20)\n</code></pre>"},{"location":"tutorial/#multiple-rate-limits","title":"Multiple Rate Limits","text":"<p>For more advanced use cases, you can apply different rate limits based on a concrete implementation of the <code>AbstractRateLimiterRepository</code>. There are two relevant methods that both get passed the current request. One method needs to identify which rate limit to apply, and the other method sets the rate limit itself. See the following example:</p> <pre><code>import httpx\nfrom httpx_limiter import (\n    AbstractRateLimiterRepository,\n    AsyncMultiRateLimitedTransport,\n    Rate\n)\nfrom httpx_limiter.aiolimiter import AiolimiterAsyncLimiter\n\n\nclass DomainBasedRateLimiterRepository(AbstractRateLimiterRepository):\n    \"\"\"Apply different rate limits based on the domain being requested.\"\"\"\n\n    def get_identifier(self, request: httpx.Request) -&gt; str:\n        \"\"\"Return the domain as the identifier for rate limiting.\"\"\"\n        return request.url.host\n\n    def create(self, request: httpx.Request) -&gt; AiolimiterAsyncLimiter:\n        \"\"\"Create a rate limiter for the domain.\"\"\"\n        return AiolimiterAsyncLimiter.create(Rate.create(magnitude=25))\n\n\nclient = httpx.AsyncClient(\n    transport=AsyncMultiRateLimitedTransport.create(\n        repository=DomainBasedRateLimiterRepository(),\n    ),\n)\n</code></pre> <p>Tip</p> <p>You are free to ignore the request parameter and use global information like the time of day to determine the rate limit.</p> <pre><code>from datetime import datetime, timezone\n\nimport httpx\nfrom httpx_limiter import AbstractRateLimiterRepository, Rate\nfrom httpx_limiter.pyrate import PyrateAsyncLimiter\n\n\nclass DayNightRateLimiterRepository(AbstractRateLimiterRepository):\n    \"\"\"Apply different rate limits based on the time of day.\"\"\"\n\n    def get_identifier(self, request: httpx.Request) -&gt; str:\n        \"\"\"Identify whether it is currently day or night.\"\"\"\n        if 6 &lt;= datetime.now(tz=timezone.utc).hour &lt; 18:\n            return \"day\"\n\n        return \"night\"\n\n    def create(self, request: httpx.Request) -&gt; PyrateAsyncLimiter:\n        \"\"\"Create a rate limiter based on the time of day.\"\"\"\n        if self.get_identifier(request) == \"day\":\n            return PyrateAsyncLimiter.create(Rate.create(magnitude=10))\n\n        return PyrateAsyncLimiter.create(Rate.create(magnitude=100))\n</code></pre>"}]}